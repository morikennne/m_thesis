
\chapter{はじめに}
\label{sec:introduction}
近年のプロセッサは，命令キャッシュ・ミスによる性能低下が問題となっている．これは，現代のアプリケーションの命令ワーキング・セットが大きくなっていることに由来する．このようなアプリケーションの例として，オンライントランザクション処理などのサーバー向けのアプリケーション~\cite{Ranganathan1998,Vaidya2008,Ferdman2012}や，JavaScriptを用いたWebアプリケーション~\cite{Zhu2015,Chadha2014}，クラウドのアプリケーション~\cite{Ferdman2012,Ayers2019}がある．これらのアプリケーションは，命令フットプリントが膨大であり，L1命令キャッシュに収まらないため，命令キャッシュ・ミスが多く発生する．命令キャッシュ・ミスが発生すると，プロセッサに実行できる命令を供給できなくなるため，それにより性能が低下する．これは近年の高性能なアウト・オブ・オーダー実行方式のプロセッサにおいても命令キャッシュ・ミスにおけるストールは隠蔽することが難しいため，重要な問題である．

この問題に対し，命令キャッシュ・ミスを減らす手法として，命令プリフェッチャがある．命令プリフェッチャは，ある命令が要求される前に，その要求を先読みして下位レベルのメモリへアクセスを行い，あらかじめその命令をキャッシュへと転送する．これを命令プリフェッチという．命令プリフェッチが成功すると，命令キャッシュ・ミスを回避できるため，性能低下を抑えることができる．

命令プリフェッチャには様々なものが提案されている．例えば，単純なものとしてミスしたラインの次のラインをプリフェッチするネクストライン・プリフェッチャがある．また，分岐予測器が持つ情報を使用するFetch Directed Instruction Prefetching~\cite{Reinman1999}や，命令キャッシュ・ミスのストリームを記録して命令プリフェッチを行うTemporal Instruction Fetch Streaming~\cite{Ferdman2008}，及びそれを改良した非常に高いプリフェッチ効果をもつProactive Instruction Fetch (PIF)~\cite{Ferdman2011}などが提案されている．

しかし，これらのプリフェッチャは，性能が高いものほど非常に大きなコストが必要になる．なぜなら，有効なプリフェッチを行うためには，複雑なキャッシュ・ミス・パターンを予測するアルゴリズムをハードウェアで実現する必要があるからである．特にPIFは，命令キャッシュ・ミスを90\%以上削減することが可能であるが，必要なストレージのサイズは一般的なL1命令キャッシュよりも非常に大きい（L1命令キャッシュが32KBに対し，200KB程度)．さらに，このようなプリフェッチャは，プリフェッチのミスに対するカバー率こそ高いものの，無駄なプリフェッチを実行することもあり，その分電力を余分に消費してしまう．

そこで，本論文では命令プリフェッチのアプローチではなく，命令フェッチ部のパイプライン構造を工夫することによって命令フェッチのスループットを向上させる以下のような手法を提案する．
\begin{enumerate}
  \item 従来の命令フェッチ・パイプラインでは，L1命令キャッシュがヒットすることを前提としてパイプラインが設計されており，命令がフェッチされるとその命令は直ちに次のステージが送られる．これに対し，本研究ではMiss-assuming Pipeline (MAP) と呼ばれる新しいパイプライン構造を提案する．MAP は L1 命令キャッシュのミスを前提としてパイプラインが設計されており，命令キャッシュがヒットしてもミスしても常に一定のレイテンシでフェッチを行う．この動作により，MAP では命令キャッシュ・ミスが発生してもフェッチのスループットを損なうことなく，実行を継続できる．
  \item しかし，MAP は従来のパイプラインと比べてパイプライン段数が増加なるため，分岐予測ミス・ペナルティが増加してしまう．MAPの 利点を最大限活用しつつこの欠点に対処するために，本研究ではフェッチのパイプライン構造を，従来のパイプラインと MAP の間で動的に切り替えて使用するアーキテクチャを提案する．同時に，本論文ではこのアーキテクチャによって得られる恩恵を最大化するための最適なパイプラインの切り替えアルゴリズムを提案する．このアルゴリズムを用いると，MAP による分岐予測ミス・ペナルティ増加の影響を最小にすることができ，得られる恩恵を最大化することができる．
\end{enumerate}

提案手法は，プリフェッチャとは異なり無駄なメモリ・アクセスを全く行わない．また，従来のプリフェッチャのような複雑な機構や大きなテーブルも必要なく，非常に低コストで構成することができる．さらに，本提案手法を適用すると，性能低下のデメリットなしに命令キャッシュ・ミスによるストールを削減でき，命令キャッシュ・ミスが多く発生するような状況においては，大きな性能向上が期待できる．

本論文の構成は次の通りである．まず，\refchap{related_work}で関連研究を示す．\refchap{miss_assumed_pipeline}では MAP について説明する．その後，\refchap{hybrid_arc}で従来の構成と MAP を組み合わせたアーキテクチャについて述べ，\refchap{sw_algorithm}では提案するパイプラインの切り替えアルゴリズムについて述べる．\refchap{evaluation}では提案手法の評価を行い，最後に\refchap{summary}でまとめる．

